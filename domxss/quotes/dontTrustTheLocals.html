<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dontTrustTheLocals</title>
    <link rel="stylesheet" type="text/css" href="../styles/sommaire.css">
</head>

<body>
    <div class="quotes">
        <h2>
            <a href="https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_01B-1_Steffens_paper.pdf" target="_blank">
                ========= Don’t Trust The Locals ========= </a>
        </h2>
        <ol>
            <li>"... we leverage <strong>taint tracking</strong> to identify suspicious flows from <strong>client-side persistent storage</strong> (Web Storage, cookies) to dangerous sinks (HTML, JavaScript, andscript.src)"</li>
            <li>
                "With our <strong>taint-aware browser</strong> and these models in mind, we study <strong>the prevalence of</strong> Persistent Client-Side XSS in the Alexa Top 5,000 domains."
            </li>
            <li>"We find that more than 8% of them have <strong>unfiltered data flows from persistent storage to a dangerous sink</strong> "
                Cross-Site Scripting enabled by <strong>persistence APIs</strong> on the client has not been acknowledged as an important type of XSS
            </li>
            <li>"we investigate the risk of using data <strong>from client-side storage in JavaScript</strong>, showing that Persistent Client-Side XSS must, in fact, be considered as a real threat to modern Web applications.""
            </li>
            <li>"We leverage taint tracking in the browser <strong>to find exploitable flows of data from Web Storage or cookies to dangerous sinks</strong>, such as eval. "</li>
            <li>"Considering a Network Attacker capable of <strong>temporarily hijacking a non-encrypted connection</strong>, and a regular Web Attacker capable of forcing her victims to visit arbitrary URLs"</li>
            <li>"These simple <strong>key-value stores are used by browsers to persist small pieces of string data, which are sent along in every HTTP request to matching servers</strong>. This allows sites <strong>to overcome the inherent limitation of HTTP, i.e., the lack of state."</strong></li>
            <li>"... introduced the Web Storage API [21]. <strong>It consists of two containers, namely Session and Local Storage. While the former only persists data for the duration of a browsing session and is unique for each window, Local Storage makes it possible to indefinitely persist data on the client.</strong>"</li>
            <li>"<strong>The most basic security policy in browsers it the SameOrigin Policy</strong> [67]. This policy governs interactions between sites, specifically as they relate to <strong>the access from JavaScript to another window. Whenever a JavaScript snippet tries to gain access to resources from another window</strong>" (e.g., popup or iframe), the action is only allowed if the accessed resource shares the origin of the JavaScript. This way, a malicious site including an iframe to another domain cannot read the content of the rendered document from that domain</li>
            <li>"Cross-Site Scripting <strong>(XSS) is a code injection attack, in which an adversary is able to add JavaScript code </strong> of her choosing to a vulnerable site."</li>
            <li>"In our notion, XSS can be roughly categorized in two dimensions. Specifically, <strong>it can be reflected or persistent, and can be located in the server-side or client-side code.</strong> Reflected here refers to the fact that the vulnerable code <strong>reflects back some attacker controllable information</strong>, e.g., using PHP’s echo functionality to print part of the requested URL on the server. Persistent in turn means that the malicious payload is not directly echoed back by the code, <strong>but rather stored and later retrieved.</strong>"</li>
            <li>"Abstractly speaking, an XSS attack occurs <strong>if some attacker controllable piece of data flows into a dangerous sink</strong>. On the client, these sinks can be classified into three <a href="https://www.youtube.com/watch?v=bouTxh76yeU&t=253s">categories</a>: <strong>rendering of HTML, execution of JavaScript, and the inclusion of additional script resources</strong>"</li>
            <li>"We then relate this concept to its server-side counterpart and introduce two<strong> attacker models</strong>, which enable <strong>storing payloads in her victim’s persistence APIs</strong>, allowing for a persistent XSS attack"</li>
            <li>"An XSS attacker’s goal is often to <strong>hijack the session of their victim</strong>, i.e., steal the authentication cookies. This problem <strong>is mitigated by the use of HTTP-only cookies</strong>, which ensure that cookies cannot be accessed from JavaScript and are therefore out of reach of the adversary"</li>
            <li>"This attack becomes more powerful if the attacker conducts a <a href="https://media.ccc.de/v/28c3-4811-en-rootkits_in_your_web_application">resident</a> <strong>XSS attack</strong> [23], which leverages the existing XSS to ensure that all links a user may visit are also XSS-infested. "</li>
            <li>"If, however, <strong>the malicious payload is persisted on the client</strong>, i.e., in cookies or Local Storage, <strong>the XSS attacker’s code is revived on every subsequent load of the flawed site</strong>, even without the necessity to add the payload to, e.g., the URL"</li>
            <li>"Although in general, Session Storage allows to persist data on the client, <strong>it is bound to a browsing window and deleted when said window is closed."</strong></li>
            <li>"A network-level adversary is able to inject arbitrary packets into any unencrypted connection between a client and server. "</li>
            <li>"<strong>Such vulnerabilities occur when an adversary’s input is not filtered or encoded before being written to persistent storage</strong>, such as a SQL database"</li>
            <li>" At the same time, <strong>when the JavaScript code</strong> causing the vulnerable flow from storage to sink is included in every page of a domain, a single injection means that regardless of which URL on the domain is visited, the attack succeeds (assuming the JavaScript snippet causing the flow is included)."</li>
            <li>"Cookies can be manipulated either by setting them <strong>in the faked HTTP response</strong>, or by delivering JavaScript code which achieves the same"</li>
            <li>" The ability to inject arbitrary cookies is hindered by <strong>HTTP Strict Transport Security</strong> (abbreviated HSTS) [22]. This HTTP header ensures that a site <strong>will only be accessible via HTTPS</strong>."</li>
            <li>"On top of this, we build a crawling extension, which recursively crawls a given domain, and reports all found data flows to a database."</li>
            <li>"Our engine is based on Chromium and is capable of attaching taint information to strings. Moreover, all JavaScript string operations (e.g., concatenation or substrings) as well as the built-in encoding functions like escape pass on the taint. We taint all values from relevant sources (e.g., Local Storage and cookies). We modified Chromium to report invocations with tainted data to numerous sinks. Specifically, this includes all sinks which allow for creation of HTML (e.g., document.write or innerHTML, execution of JavaScript code (e.g., eval) as well as adding additional script resources (via script.src). Apart from these flows which might lead to a direct JavaScript execution, the engine also collects those flows that end in a persistent storage, specifically cookies and Local Storage. On top of this, we build a crawling extension, which recursively crawls a given domain, and reports all found data flows to a database."</li>
            <li>"To craft an exploit, our original approach would generate a sequence <strong>which breaks out of the existing context</strong> and subsequently calls some function, e.g., alert."</li>
            <li>"In order to determine how many of these flows could, in fact, be exploited, we first determined how many domains would be attackable by an unlimited adversary, i.e., <strong>an adversary capable of modifying cookies or Local Storage for arbitrary origins</strong>. To that end, we used a Chrome extension to first visit each URL in question, modify the storage accordingly, and reload the site"</li>
            <li>" First, since cookies are sent along to the server in every HTTP request, <strong>they are subject to inspection by deployed Web Application Firewalls</strong> (WAFs). Although we did not specifically record when a page was not loaded due to our cookies containing JavaScript or HTML markup, sampling sites on which our payload had not triggered frequently led to error pages clearly caused by WAFs"</li>
            <li>"Considering the Network Attacker, we found that 293 of the 418 domains would, in fact, be exploitable, either due to a complete lack of HTTPS or due to a missing or incomplete (<strong>no includeSubDomains</strong>) deployment of HSTS, which allows for an HTTP-hosted site to set cookies for its HTTPS counterpart and parents."</li>
            <li>"In our study, we found the single sign-on part of a major Chinese website network to be susceptible to both a persistent and a reflected Client-Side XSS flaw. While abusing the reflected XSS could have been used <strong>to exfiltrate the cookies</strong> of the user, these <strong>were protected with the HttpOnly flag</strong>. Given the fact that the same origin also made insecure use of persisted code from Local Storage, however, rather than trying to steal the cookie, <strong>we built a proof of concept that extracted credentials from the login field right before the submission</strong> of the credentials to the server. This way, <strong>although a single session cannot be hijacked</strong>, the attacker can easily steal the credentials when these are entered by the unknowing victim"</li>
            <li>"Hence, replacing eval with the browser’s native JSON capabilities is sufficient to robustly secure these cases. Indeed, a total of 81 vulnerable domains in our dataset could be fixed by simply using JSON.parse. However, eval-based JSON parsing is much more forgiving with respect to syntactical constraints compared to the browser’s fairly strict JSON parser."</li>
            <li>"The most challenging pattern in our dataset consists of scenarios in which applications use the persistence mechanisms to deliberately store HTML or JavaScript code, e.g., for client-side caching purposes."</li>
            <li>"In modern browsers, Service Workers [47], which were introduced as a more capable replacement of the <strong>AppCache</strong> mechanism, can be leveraged for this purpose". <strong>They allow Web sites to introduce their own custom caching and offline mechanism</strong>, which is based on JavaScript-driven interception of HTTPS requests</li>
            <li>"As the Service Worker code <strong>runs completely separated from the document’s JavaScript</strong>, this functionality <strong>cannot be influenced by the Web Attacker</strong> and, as Service Workers are an <strong>HTTPS-only feature, the Network Attacker is also rendered harmless</strong>."</li>
            <li>"Specifically, the W3C has proposed the <a href="https://www.w3.org/TR/clear-site-data/">Clear-Site-Data response header</a>. This mechanism allows site operators to truncate all client-side storage and moreover shut down all JavaScript contexts to ensure that an attacker-controlled context is unable to re-poison the storage. However, making use of this mechanism regularly inevitably destroys the purpose of having client-side storage, be it code or configuration data storage."</li>
            <li>"While the exploitability of flows originating from storage does not depend on the browser, <strong>the susceptibility of a site to a reflected Client-Side XSS varies between browsing engines</strong>. Specifically, Firefox automatically encodes all parts of the URL when accessed via the location object; Chrome did not do so until version 65. Since version 65, however, the auto-encoding has changed such that the URL fragment is also encoded, meaning that exploits which target an unfiltered and unmodified flow <strong>from the fragment to a sink will not be exploitable anymore</strong>"</li>
            <li>"In 2015, Zheng et al. [68] analyzed the general risks associated with the lack of integrity of cookie data. <strong>Their threat model also covers a Network and Web Attacker</strong>, which allows them to find instances of session hijacking, history stealing, and even XSS flaws"</li>
            <li>"Another approach to tackle the specifics of Client-Side XSS is <strong>extending the taint tracking approach from Lekies et al.[32] to the parser level</strong>. In doing so, Stock et al. [54] were able to <strong>prevent tainted values from being interpreted as code</strong>, thus stopping all previously verified cases of reflected Client-Side XSS. Extending this to storage, however, would not work, given the inability to distinguish attacker-injected payloads in the storages, resulting either in false negatives or impaired functionality. <strong>The general idea of this solution was since refactored into Trusted Types</strong> [8], which prevent undesired code flows into code executing sinks, but have yet to be introduced into browsers."</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
            <li>""</li>
        </ol>
    </div>
</body>

</html>